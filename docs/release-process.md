# The Release Process

- When releasing, create signed commits and tags;
  - You will need to use the CLI, but then just access and use the GitHub GUI as usual.
- We do create OpenPGP-signed releases on GitHub [1]. To sign the source code tarball:

  ```bash
  # Create a release
  # Download the tarball <name>.tar.gz generated by GitHub, then
  gpg --armor --detach-sign --output Digitally-signed.tar.gz.asc THE-DOWNLOADED-TARBALL-RELEASE-FILE.tar.gz
  ```

- Then, upload the Digitally-signed.tar.gz.asc file to the newly created GitHub release.

## The Bleeding Release

We emphasize that the bleeding version is a trial version. Whenever a new "bleeding" release is created,
all logs and binaries previously called "bleeding" are erased and lost. Therefore, there is an obvious
traceability problem; in addition, it is necessary to highlight the possibility that the bleeding
package is based on commits not suitable for use in production.

Thus, using the bleeding package in temporary test environments is fine, but the end user should
not use it for day by day tasks, which, by the way, is exactly what is happening in the Windows version.

## Tasks for Creating a Release

- [ ] Ensure the `release` branch is up to date and clean;
  - The `release` branch is a copy of the `main` branch;
  - From this point onwards, changes to the source code that are not listed must cause a restart from
    the beginning.
- [ ] Add a new commit to the `release` branch;
  - This is the "pin upstream commit".
- [ ] Update the commit that will be used to build;
  - Replace all occurrences of `f9fedd238b0b1d69181c1fef033b85c787e96e57` with the proper commit hash;
  - Replace all occurrences of `f9fedd2` with the proper short commit hash;
  - Update bash script [file hashes](../CONTRIBUTING.md#create-a-suitable-pr);
  - Amend and push the "pin upstream commit".

The "pin upstream commit" is ready.

- [ ] Add a new commit to the `release` branch;
  - This is the "release commit".
- [ ] Update all release-related documentation;

  - Update all texts that need to be changed;
  - Update the `Release.ID` file;

    ```text
    Examples:
    1.9+           # Development version
    1.9+2404       # Rolling release
    v1.10.0        # A real release
    ```

  - Amend and push the "release commit".

The "release commit" is almost ready.

- [ ] Run all CI (standard, macOS, GitLab, Solaris and Android); [2]
  - Confirm that all builds are OK.
- [ ] Build the snap (use Launchpad); [3]
  - Confirm that all builds are OK.

If you are creating a "real release", perform a cherry-pick, merge, and push the "pin upstream commit"
into the main branch. See note [*].

- [ ] Build the Docker image (bleeding or latest); [4]
  - If you are creating a bleeding version, run the workflow from the `release` branch
    (`main` doesn't know the proper commit hash). See note [*];
  - Confirm that all builds are OK.
- [ ] Release to snap store and flathub;

All binaries are ready.

- [ ] Update versions of the software used for packaging (in deploy/readme and CI/readme); [5]
  - Amend and push the "release commit";
  - This is also a valid point for performing the merge. See note [*].

The "release commit" is ready.

- [ ] Add a new commit to the `release` branch;
  - This is the "logs commit".
- [ ] Update all logs in /Releases/[RELEASE]; [6]
  - Amend and push the "logs commit".

The "logs commit" is ready.

- [ ] Merge the PR; [7]
  - Go to the `main` branch and use a fast forward merge;
  - `git checkout main; git merge --ff-only release`.
- [ ] Create the release tag; [8]
  - `git tag <tag> -m "release: <tag> $(date +%Y%m%d)"`.
- [ ] Update the repository;
  - `git push -u origin main`;
  - `git push --tags`.
- [ ] Release the GitHub release.
  - Use Azure to release it.

Footnotes:

1. this way users can verify whether what they received matches the same tarball we have released;
2. all files that will be in the GitHub release are ready to go. Still need to be released;
3. all snap packages are ready to go. Still need to be released;
4. the Docker image will be automatically deployed;
5. manual task of accessing logs and copying information;
6. update and run get-files.sh;
7. the release itself is based on the last commit and its Git tag;
   naturally, you will only merge if you are working in a "real release".
8. e.g., for a rolling release in Oct 2023, the `<tag>` value should be rolling-2310.

> [!NOTE]
>
> [*]:
> we use the `release` branch as a staging area, so that we can build development packages
> without polluting the `main` branch. In case of real releases, the maintainer is free to
> merge the changes as soon as they are ready, on the other hand, incomplete and staging
> release changes cannot be added to the main branch.
>
> Of course, you can release an official version without relying on a working branch
> like the `release` branch. Note, however, that the lack of a `release` branch would make it
> impossible to create a development and test version of the package (the bleeding release).
